{
  "operations": [
    {
      "file": "src/tutorial-fx.js",
      "op": "insert_before",
      "anchor": "if\\(frontCtx\\)\\s*frontCtx\\.restore\\(\\);",
      "id": "ROUNDED_CARD_MASK_V3",
      "text": "\n/* << GPT:ROUNDED_CARD_MASK_V3 START >> */\n// Erase front-canvas exactly under the highlighted bevelled card (per-corner radii).\ntry {\n  if (typeof frontCtx !== 'undefined' && frontCtx && typeof frontCanvas !== 'undefined' && frontCanvas) {\n    const active =\n      document.querySelector('#tutorial-goals .goal-row.is-active, #tutorial-goals .goal-task.is-active') ||\n      document.querySelector('#tutorial-goals .goal-row, #tutorial-goals .goal-task');\n    if (active) {\n      // If the highlight/border is on a child, pick the largest rounded, non-transparent descendant\n      const px = v => (v ? parseFloat(String(v).replace(/[^0-9.]/g, '')) || 0 : 0);\n      const list = [active, ...active.querySelectorAll('*')];\n      let best = null;\n      for (const el of list) {\n        const cs = getComputedStyle(el);\n        const tl = Math.max(px(cs.borderTopLeftRadius),  px(cs.borderRadius));\n        const tr = Math.max(px(cs.borderTopRightRadius), px(cs.borderRadius));\n        const br = Math.max(px(cs.borderBottomRightRadius),px(cs.borderRadius));\n        const bl = Math.max(px(cs.borderBottomLeftRadius), px(cs.borderRadius));\n        const hasRadius = (tl || tr || br || bl) > 2;\n        const bg = cs.backgroundColor;\n        const hasBg = bg && bg !== 'transparent' && bg !== 'rgba(0, 0, 0, 0)';\n        if (!hasRadius || !hasBg) continue;\n        const r = el.getBoundingClientRect();\n        const area = Math.max(1, r.width * r.height);\n        if (!best || area > best.area) best = { r, tl, tr, br, bl, area };\n      }\n      const target = best || { r: active.getBoundingClientRect(), tl: 12, tr: 12, br: 12, bl: 12 };\n      const { r, tl, tr, br, bl } = target;\n\n      // Slight inset so we don't erase the border stroke itself\n      const inset = 2;\n\n      // Determine the coordinate units the context expects:\n      // If the context is scaled (common dpr scaling), draw in CSS px (scale\u2248dpr).\n      // Else convert CSS px -> device px using dpr.\n      let unit = 1;\n      try {\n        const m = frontCtx.getTransform ? frontCtx.getTransform() : null;\n        const scaleX = m ? m.a : 1;\n        if (Math.abs(scaleX - 1) < 0.05) {\n          // unscaled context -> use device px\n          const dpr = (frontCanvas.clientWidth > 0) ? (frontCanvas.width / frontCanvas.clientWidth) : (window.devicePixelRatio || 1);\n          unit = dpr;\n        } else {\n          // scaled context -> CSS px\n          unit = 1;\n        }\n      } catch (_) { unit = 1; }\n\n      const x = (r.left + inset) * unit;\n      const y = (r.top  + inset) * unit;\n      const w = Math.max(0, (r.width  - inset * 2) * unit);\n      const h = Math.max(0, (r.height - inset * 2) * unit);\n\n      const roundedPath = (ctx, x, y, w, h, tl, tr, br, bl) => {\n        const _tl = Math.min(tl * unit, Math.min(w, h) / 2);\n        const _tr = Math.min(tr * unit, Math.min(w, h) / 2);\n        const _br = Math.min(br * unit, Math.min(w, h) / 2);\n        const _bl = Math.min(bl * unit, Math.min(w, h) / 2);\n        ctx.beginPath();\n        ctx.moveTo(x + _tl, y);\n        ctx.lineTo(x + w - _tr, y);\n        ctx.quadraticCurveTo(x + w, y, x + w, y + _tr);\n        ctx.lineTo(x + w, y + h - _br);\n        ctx.quadraticCurveTo(x + w, y + h, x + w - _br, y + h);\n        ctx.lineTo(x + _bl, y + h);\n        ctx.quadraticCurveTo(x, y + h, x, y + h - _bl);\n        ctx.lineTo(x, y + _tl);\n        ctx.quadraticCurveTo(x, y, x + _tl, y);\n        ctx.closePath();\n      };\n\n      frontCtx.save();\n      frontCtx.globalCompositeOperation = 'destination-out';\n      // Tiny feather to hide any seam\n      frontCtx.shadowBlur = 1.5 * unit;\n      frontCtx.shadowColor = 'rgba(0,0,0,0.25)';\n      roundedPath(frontCtx, x, y, w, h, tl, tr, br, bl);\n      frontCtx.fill();\n      frontCtx.restore();\n    }\n  }\n} catch (e) { /* no-op */ }\n/* << GPT:ROUNDED_CARD_MASK_V3 END >> */\n"
    },
    {
      "file": "src/tutorial.js",
      "op": "insert_before",
      "anchor": "requestAnimationFrame\\(\\s*\\(\\)\\s*=>\\s*\\{",
      "id": "TUTORIAL_DRAW_TOY_SIZE_V2",
      "text": "\n/* << GPT:TUTORIAL_DRAW_TOY_SIZE_V2 START >> */\n// Make the Draw toy panel large so the existing centering code uses the new size\ntry {\n  if (panel && panel.style) {\n    panel.style.position = 'absolute';\n    panel.style.width = 'min(960px, 80vw)';\n    panel.style.height = 'min(640px, 70vh)';\n    panel.style.maxWidth = 'calc(100vw - 64px)';\n    panel.style.maxHeight = 'calc(100vh - 128px)';\n  }\n} catch (_) {}\n/* << GPT:TUTORIAL_DRAW_TOY_SIZE_V2 END >> */\n"
    }
  ]
}